---
type: chapter
status: completed
created: 2026-01-25
tags:
  - CSAPP
---

笔记：[[第2章-信息的表示和处理]]

**2.1 完成下面的数字转换**
1. Ox39A7F8 转换为二进制。
    0b0011'1001'1010'0111'1111'1000
2. 将二进制 1100100101111011 转换为十六进制。
    0xC97B
3. OxD5E4C 转换为二进制。
    0b1101'0101'1110'0100'1100
4. 将二进制 10'0110'1110'0111'1011'0101 转换为十六进制。
    0x26E7B5

**2.2 填写下表中的空白项，给出 2 的不同次幂的二进制和十六进制表示**

| $n$ | $2^n$ (十进制) | $2^n$ (十六进制) |
| :-- | :---------- | :----------- |
| 9   | 512         | 0x200        |
| 19  | 524288      | 0x80000      |
| 14  | 16384       | 0x8000       |
| 16  | 65536       | 0x10000      |
| 17  | 131072      | 0x20000      |
| 5   | 32          | 0x20         |
| 7   | 128         | 0x80         |

**2.3 一个字节可以用两个十六进制数字来表示。填写下表中缺失的项，给出不同字节模式的十进制、二进制和十六进制值**

| 十进制 | 二进制       | 十六进制 |
| :-- | :-------- | :--- |
| 0   | 0000 0000 | 0x00 |
| 167 | 1010 0111 | 0xA7 |
| 62  | 0011 1110 | 0x3E |
| 188 | 1011 1100 | 0xBC |
| 55  | 0011 0111 | 0x37 |
| 136 | 1000 1000 | 0x88 |
| 243 | 1111 0011 | 0xF3 |
| 82  | 0101 0010 | 0x52 |
| 172 | 1010 1110 | 0xAC |
| 231 | 1110 0111 | 0xE7 |

**2.4 不将数字转换为十进制或者二进制，试着解答下面的算术题，答案要用十六进制表示。提示：只要将执行十进制加法和减法所使用的方法改成以 16 为基数。**
1. Ox503c+Ox8=<u>0x5044</u>
2. Ox503c-Ox40=<u>0x4ffc</u>
3. Ox503c+64=<u>0x507c</u>
4. Ox50ea-Ox503c=<u>0xae</u>

**2.5 思考下面对 `show_bytes` 的三次调用**

> [!note]- show_bytes 代码
> ```c
> #include <stdio.h>
>
> typedef unsigned char *byte_pointer;
>
> void show_bytes(byte_pointer start, size_t len) {
>     for (size_t i = 0; i < len; i++) {
>         printf(" %.2x", start[i]);
>     }
>     printf("\n");
> }
>
> void show_int(int x) {
>     show_bytes((byte_pointer) &x, sizeof(int));
> }
>
> void show_float(float x) {
>     show_bytes((byte_pointer) &x, sizeof(float));
> }
>
> void show_pointer(void *x) {
>     show_bytes((byte_pointer) &x, sizeof(void *));
> }
> ```

```c
int val= Ox87654321;
byte_pointer valp = (byte_pointer) &val;

show_bytes(valp, 1); /* 1. */
show_bytes(valp, 2); /* 2. */
show_bytes(valp, 3); /* 3. */
```

指出在小端法机器和大端法机器上，每次调用的输出值。
1. 小端法：`21` 大端法：`87`
2. 小端法：`21 43` 大端法：`87 65`
3. 小端法：`21 43 65` 大端法：`87 65 43`

**2.6 使用 `show_int` 和 `show_float`，我们确定整数 3510593 的十六进制表示为 `0x00359141`，而浮点数 3510593.0 的十六进制表示为 `0x4A564504`。** ^c944db

1. 写出这两个十六进制值的二进制表示。
    `0b0000'0000'0011'0101'1001'0001'0100'0001`
    `0b0100'1010'0101'0110'0100'0101'0000'0100`
2. 移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢？
    ```
       0   0   3   5   9   1   4   1
    00000000001101011001000101000001
               *********************
         4   A   5   6   4   5   0   4
      01001010010101100100010100000100
    ```
    有 21 位相配。
3. 串中的什么部分不相匹配？
    除了整数的最高有效位，其余位都相配。

**2.7 下面对 `show_bytes` 的调用将输出什么结果？**

```c
const char *s = "abcdef";
show_bytes((byte_pointer) s, strlen(s));
```

注意字母 'a' ~ 'z' 的 ASCII 码为 `0x61` ~ `0x7A`。

输出 `61 62 63 64 65 66 00`。

**2.8 填写下表，给出位向量的布尔运算的求值结果。**

| 运算           | 结果         |
| :----------- | :--------- |
| $a$          | [01101001] |
| $b$          | [01010101] |
| $\sim a$     | [10010110] |
| $\sim b$     | [10101010] |
| $a \& b$     | [01000001] |
| $a \mid b$   | [01111101] |
| $a \wedge b$ | [00111100] |

**2.9**
![[Pasted image 20260125160514.png]]

1. 相当于翻转整个序列
2. 蓝绿色、绿色、蓝色

**2.10 对于任一位向量 $a$，有 $a \wedge a = 0$。应用这一属性，考虑下面的程序：**

```c
void inplace_swap(int *x, int *y) {
    *y = *x ^ *y; /* Step 1 */
    *x = *x ^ *y; /* Step 2 */
    *y = *x ^ *y; /* Step 3 */
}
```

正如程序名字所暗示的那样，我们认为这个过程的效果是交换指针变量 $x$ 和 $y$ 所指向的存储位置处存放的值。注意，与通常的交换两个数值的技术不一样，当移动一个值时，我们不需要第三个位置来临时存储另一个值。这种交换方式并没有性能上的优势，它仅仅是一个智力游戏。

以指针 $x$ 和 $y$ 指向的位置存储的值分别是 $a$ 和 $b$ 作为开始，填写下表，给出在程序的每一步之后，存储在这两个位置中的值。利用 $\wedge$ 的属性证明达到了所希望的效果。回想一下，每个元素就是它自身的加法逆元 ($a \wedge a = 0$)。

| **步骤** | ***x** | ***y**       |
| ------ | ------ | ------------ |
| 初始     | $a$    | $b$          |
| 第1步    | $a$    | $a \wedge b$ |
| 第2步    | $b$    | $a \wedge b$ |
| 第3步    | $b$    | $a$          |

**2.11** 在练习题 2.10 中的 `inplace_swap` 函数的基础上，你决定写一段代码，实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数：

```c
void reverse_array(int a[], int cnt) {
    int first, last;
    for (first = 0, last = cnt-1;
         first <= last;
         first++,last--)
        inplace_swap(&a[first], &a[last]);
}
````

当你对一个包含元素 1、2、3 和 4 的数组使用这个函数时，正如预期的那样，现在数组的元素变成了 4、3、2 和 1。不过，当你对一个包含元素 1、2、3、4 和 5 的数组使用这个函数时，你会很惊奇地看到得到数字的元素为 5、4、0、2 和 1。实际上，你会发现这段代码对所有偶数长度的数组都能正确地工作，但是当数组的长度为奇数时，它就会把中间的元素设置成 0。

1. 对于一个长度为奇数的数组，长度 $cnt = 2k+1$，函数 `reverse_array` 最后一次循环中，变量 `first` 和 `last` 的值分别是什么？
    都是 $k$
2. 为什么这时调用函数 `inplace_swap` 会将数组元素设置为 0？
    $k \wedge k = 0$
3. 对 `reverse_array` 的代码做哪些简单改动就能消除这个问题？
    `first < last`

**2.12** 对于下面的值，写出变量 x 的 C 语言表达式。你的代码应该对任何字长 $w \geqslant 8$ 都能工作。我们给出了当 x=0x87654321 以及 $w=32$ 时表达式求值的结果，仅供参考。

1. x 的最低有效字节，其他位均置为 0。[0x00000021]。
    `x & 0x000000FF`
2. 除了 x 的最低有效字节外，其他的位都取补，最低有效字节保持不变。[0x789ABC21]。
    `x ^ 0xFFFFFF00`
3. x 的最低有效字节设置成全 1，其他字节都保持不变。[0x876543FF]。
    `x | 0x000000FF`

**2.13** 从 20 世纪 70 年代末到 80 年代末，Digital Equipment 的 VAX 计算机是一种非常流行的机型。它没有布尔运算 AND 和 OR 指令，只有 bis(位设置)和 bic(位清除)这两种指令。两种指令的输入都是一个数据字 x 和一个掩码字 m。它们生成一个结果 z，z 是由根据掩码 m 的位来修改 x 的位得到的。使用 bis 指令，这种修改就是在 m 为 1 的每个位置上，将 z 对应的位设置为 1。使用 bic 指令，这种修改就是在 m 为 1 的每个位置，将 z 对应的位设置为 0。

为了看清楚这些运算与 C 语言位级运算的关系，假设我们有两个函数 bis 和 bic 来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他 C 语言运算，来实现按位 | 和 ^ 运算。填写下列代码中缺失的代码。提示：写出 bis 和 bic 运算的 C 语言表达式。

对于 `bool_or`，易得。
对于 `bool_xor`，有 $x \oplus y = \overline{x}y+x\overline{y}$，又有 $\operatorname{bic}(x, m) = x\overline{m}$。

```c
/* Declarations of functions implementing operations bis and bic */
int bis(int x, int m);
int bic(int x, int m);

/* Compute x|y using only calls to functions bis and bic */
int bool_or(int x, int y) {
    int result = bis(x, y);
    return result;
}

/* Compute x^y using only calls to functions bis and bic */
int bool_xor(int x, int y) {
    int result = bis(bic(x, y), bic(y, x));
    return result;
}
```


**2.14** 假设 x 和 y 的字节值分别为 0x66 和 0x39。填写下表，指明各个 C 表达式的字节值。

| 表达式        | 值    | 表达式          | 值    |
| :--------- | :--- | :----------- | :--- |
| `x & y`    | 0x20 | `x && y`     | 0x01 |
| `x \| y`   | 0x7F | `x \|\| y`   | 0x01 |
| `~x \| ~y` | 0xDF | `!x \|\| !y` | 0x00 |
| `x & !y`   | 0x00 | `x && ~y`    | 0x01 |

**2.15** 只使用位级和逻辑运算，编写一个 C 表达式，它等价于 `x==y` 。换句话说，当 x 和 y 相等时它将返回 1, 否则就返回 0。
`!(x^y)`

**2.16** 填写下表，展示不同移位运算对单字节数的影响。思考移位运算的最好方式是使用二进制表示。将最初的值转换为二进制，执行移位运算，然后再转换回十六进制。每个答案都应该是 8 个二进制数字或者 2 个十六进制数字。

| x    | x         | x << 3    | x << 3 | x >> 2 (逻辑的) | x >> 2 (逻辑的) | x >> 2 (算术的) | x >> 2 (算术的) |
| :--- | :-------- | :-------- | :----- | :----------- | :----------- | :----------- | :----------- |
| 十六进制 | 二进制       | 二进制       | 十六进制   | 二进制          | 十六进制         | 二进制          | 十六进制         |
| 0xC3 | 1100 0011 | 0001 1000 | 0x18   | 0011 0000    | 0x30         | 1111 0000    | 0xF0         |
| 0x75 | 0111 0101 | 1010 1000 | 0xA8   | 0001 1101    | 0x1D         | 0001 1101    | 0x1D         |
| 0x87 | 1000 0111 | 0011 1000 | 0x38   | 0010 0001    | 0x21         | 1110 0001    | 0xE1         |
| 0x66 | 0110 0110 | 0011 0000 | 0x30   | 0001 1001    | 0x19         | 0001 1001    | 0x19         |

**2.17** 假设 $w=4$，我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。请根据这些表示，通过写出等式(2.1)和等式(2.3)所示的求和公式中的 2 的非零次幂，填写下表：

| 十六进制 | 二进制    | $B2U_4(\vec{x})$                     | $B2T_4(\vec{x})$                      |
| :--- | :----- | :----------------------------------- | :------------------------------------ |
| 0xE  | [1110] | $2^3+2^2+2^1=14$                     | $-2^3+2^2+2^1=-2$                     |
| 0x0  | [0000] | $0$                                  | $0$                                   |
| 0x5  | [0101] | $2^{2} + 2^{0} = 5$                  | $5$                                   |
| 0x8  | [1000] | $2^{3} = 8$                          | $-2^{3} = -8$                         |
| 0xD  | [1101] | $2^{3} + 2^{2} + 2^{0} = 13$         | $-2^{3} + 2^{2} + 2^{0} = -3$         |
| 0xF  | [1111] | $2^{3} + 2^{2} + 2^{1} + 2^{0} = 15$ | $-2^{3} + 2^{2} + 2^{1} + 2^{0} = -1$ |

**2.18** 在第 3 章中，我们将看到由反汇编器生成的列表，反汇编器是一种将可执行程序文件转换回可读性更好的 ASCII 码形式的程序。这些文件包含许多十六进制数字，都是用典型的补码形式来表示这些值。能够认识这些数字并理解它们的意义（例如它们是正数还是负数），是一项重要的技巧。
在下面的列表中，对于标号为 A～I（标记在右边）的那些行，将指令名（sub、mov 和 add）右边显示的（32 位补码形式表示的）十六进制值转换为等价的十进制值。

```objdump
4004d0:  48 81 ec e0 02 00 00     sub    $0x2e0,%rsp              A. 736
4004d7:  48 8b 44 24 a8           mov    -0x58(%rsp),%rax         B. -88
4004dc:  48 03 47 28              add    0x28(%rdi),%rax          C. 40
4004e0:  48 89 44 24 d0           mov    %rax,-0x30(%rsp)         D. -48
4004e5:  48 8b 44 24 78           mov    0x78(%rsp),%rax          E. 120
4004ea:  48 89 87 88 00 00 00     mov    %rax,0x88(%rdi)          F. 136
4004f1:  48 8b 84 24 f8 01 00     mov    0x1f8(%rsp),%rax         G. 504
4004f8:  00
4004f9:  48 03 44 24 08           add    0x8(%rsp),%rax
4004fe:  48 89 84 24 c0 00 00     mov    %rax,0xc0(%rsp)          H. 192
400505:  00
400506:  48 8b 44 d4 b8           mov    -0x48(%rsp,%rdx,8),%rax  I. -72
```


**2.19** 利用你解答练习题 2.17 时填写的表格，填写下列描述函数 $T2U_4$ 的表格。

| $x$ | $T2U_4(x)$ |
| :-- | :--------- |
| -8  | 8          |
| -3  | 13         |
| -2  | 14         |
| -1  | 15         |
| 0   | 0          |
| 5   | 5          |
参见 [[第2章-信息的表示和处理#有符号数和无符号数之间的转换]]。

**2.20** 请说明等式 (2.5) 是如何应用到解答练习题 2.19 时生成的表格中的各项的。
略。


**2.21** 假设在采用补码运算的 32 位机器上对这些表达式求值，按照图 2-19 的格式填写下表，描述强制类型转换和关系运算的结果。

| 表达式                            | 类型  | 求值  |
| :----------------------------- | :-- | :-- |
| `-2147483647-1 == 2147483648U` | 无符号 | 1   |
| `-2147483647-1 < 2147483647`   | 有符号 | 1   |
| `-2147483647-1U < 2147483647`  | 无符号 | 0   |
| `-2147483647-1 < -2147483647`  | 有符号 | 1   |
| `-2147483647-1U < -2147483647` | 无符号 | 1   |

**2.22** 通过应用等式 (2.3)，表明下面每个位向量都是 $-5$ 的补码表示。
1. [1011]
2. [11011]
3. [111011]
参见[[第2章-信息的表示和处理#^005eed]]。

**2.23** 考虑下面的 C 函数：

```c
int fun1(unsigned word) {
    return (int) ((word << 24) >> 24);
}

int fun2(unsigned word) {
    return ((int) word << 24) >> 24;
}
```

假设在一个采用补码运算的机器上以 32 位程序来执行这些函数。还假设有符号数值的右移是算术右移，而无符号数值的右移是逻辑右移。

1. 填写下表，说明这些函数对几个示例参数的结果。你会发现用十六进制表示来做会更方便，只要记住十六进制数字 8 到 F 的最高有效位等于 1。

| **w**      | **fun1(w)** | **fun2(w)** |
| ---------- | ----------- | ----------- |
| 0x00000076 | 0x00000076  | 0x00000076  |
| 0x87654321 | 0x00000021  | 0x00000021  |
| 0x000000C9 | 0x000000C9  | 0xFFFFFFC9  |
| 0xEDCBA987 | 0x00000087  | 0xFFFFFF87  |

2. 用语言来描述这些函数执行的有用的计算。
    函数 `fun1` 从参数的低 $8$ 位中提取一个值。函数 `fun2` 也是，但是执行符号扩展。

**2.24** 假设将一个 4 位数值（用十六进制数字 0～F 表示）截断到一个 3 位数值（用十六进制数字 0～7 表示）。填写下表，根据那些位模式的无符号和补码解释，说明这种截断对某些情况的结果。

| 十六进制 原始值 | 十六进制 截断值 | 无符号 原始值 | 无符号 截断值 | 补码 原始值 | 补码 截断值 |
| :------- | :------- | :------ | :------ | :----- | :----- |
| 0        | 0        | 0       | 0       | 0      | 0      |
| 2        | 2        | 2       | 2       | 2      | 2      |
| 9        | 1        | 9       | 1       | -7     | 1      |
| B        | 3        | 11      | 3       | -5     | 3      |
| F        | 7        | 15      | 7       | -1     | -1     |

解释如何将等式(2.9)和等式(2.10)应用到这些示例上。
参见 [[第2章-信息的表示和处理#整形截断]]。

**练习题 2.25** 考虑下列代码，这段代码试图计算数组 a 中所有元素的和，其中元素的数量由参数 length 给出。

```c
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length) {
    int i;
    float result = 0;

    for (i = 0; i <= length-1; i++)
        result += a[i];
    return result;
}
```

当参数 length 等于 0 时，运行这段代码应该返回 0.0。但实际上，运行时会遇到一个内存错误。请解释为什么会发生这样的情况，并且说明如何修改代码。

错误原因：`0U-1 = 0xFFFFFFFF = UMax`，改为 `i < length`。



**2.26** 现在给你一个任务，写一个函数用来判定一个字符串是否比另一个更长。前提是你要用字符串库函数 strlen，它的声明如下：

```c
/* Prototype for library function strlen */
size_t strlen(const char *s);
````

最开始你写的函数是这样的：

```
/* Determine whether string s is longer than string t */
/* WARNING: This function is buggy */
int strlonger(char *s, char *t) {
    return strlen(s) - strlen(t) > 0;
}
```

当你在一些示例数据上测试这个函数时，一切似乎都是正确的。进一步研究发现在头文件 stdio.h 中数据类型 `size_t` 是定义成 `unsigned int` 的。

1. 在什么情况下，这个函数会产生不正确的结果？
    $|s| < |t|$ 时。 
2. 解释为什么会出现这样不正确的结果。
    无符号运算，差为负时变成一个很大的数。
3. 说明如何修改这段代码好让它能可靠地工作。
    `return strlen(s) > strlen(t)`


**2.27** 写出一个具有如下原型的函数：

```c
/* Determine whether arguments can be added without overflow */
int uadd_ok(unsigned x, unsigned y);
````

如果参数 x 和 y 相加不会产生溢出，这个函数就返回 1。

```c
int uadd_ok(unsigned x, unsigned y) {
    return (x + y) >= x;
}
```

参见 [[第2章-信息的表示和处理#溢出判断]]。


**2.28** 我们能用一个十六进制数字来表示长度 $w=4$ 的位模式。对于这些数字的无符号解释，使用等式 (2.12) 填写下表，给出所示数字的无符号加法逆元的位表示（用十六进制形式）。

| $x$ (十六进制) | $x$ (十进制) | $-^u_4 x$ (十进制) | $-^u_4 x$ (十六进制) |
| :--------- | :-------- | :-------------- | :--------------- |
| 0          | 0         | 0               | 0                |
| 5          | 5         | 11              | B                |
| 8          | 8         | 8               | 8                |
| D          | 13        | 3               | 3                |
| F          | 15        | 1               | 1                |
参见 [[第2章-信息的表示和处理#求反]]。



**2.29** 按照图 2-25 的形式填写下表。分别列出 5 位参数的整数值、整数和与补码和的数值、补码和的位级表示，以及属于等式(2.13)推导中的哪种情况。

| $x$         | $y$         | $x+y$ | $x+^t_5 y$ | 情况  |
| :---------- | :---------- | :---- | :--------- | :-- |
| [10100] -12 | [10001] -15 | -27   | 5          | 1   |
| [11000] -8  | [11000] -8  | -16   | -16        | 2   |
| [10111] -9  | [01000] 8   | -1    | -1         | 2   |
| [00010] 2   | [00101] 5   | 7     | 7          | 3   |
| [01100] 12  | [00100] 4   | 16    | -16        | 4   |



**2.30** 写出一个具有如下原型的函数：

```c
/* Determine whether arguments can be added without overflow */
int tadd_ok(int x, int y);
````

如果参数 x 和 y 相加不会产生溢出，这个函数就返回 1。

```c
int tadd_ok(int x, int y) {
    return !(x > 0 && y > 0 && (x + y) <= 0) && !(x < 0 && y < 0 && (x + y) >= 0);
}
```

同理，参见 [[第2章-信息的表示和处理#溢出判断]]。


**2.31** 你的同事对你补码加法溢出条件的分析有些不耐烦了，他给出了一个函数 `tadd_ok` 的实现，如下所示：

```c
/* Determine whether arguments can be added without overflow */
/* WARNING: This code is buggy. */
int tadd_ok(int x, int y) {
    int sum = x+y;
    return (sum-x == y) && (sum-y == x);
}
````

你看了代码以后笑了。解释一下为什么。

补码加法是一个阿贝尔群，所以判断时恒真。换句话说，溢出之后，判断式又溢出回来了。


**2.32** 你现在有个任务，编写函数 tsub_ok 的代码，函数的参数是 x 和 y，如果计算 x-y 不产生溢出，函数就返回 1。假设你写的练习题 2.30 的代码如下所示：

```c
/* Determine whether arguments can be subtracted without overflow */
/* WARNING: This code is buggy. */
int tsub_ok(int x, int y) {
    return tadd_ok(x, -y);
}
````

x 和 y 取什么值时，这个函数会产生错误的结果？写一个该函数的正确版本（家庭作业 2.74）。

当 $y = TMin$ 时，会产生错误的结果。


**2.33** 我们可以用一个十六进制数字来表示长度 $w=4$ 的位模式。根据这些数字的补码的解释，填写下表，确定所示数字的加法逆元。

| $x$ (十六进制) | $x$ (十进制) | $-^t_4 x$ (十进制) | $-^t_4 x$ (十六进制) |
| :--------- | :-------- | :-------------- | :--------------- |
| 0          | 0         | 0               | 0                |
| 5          | 5         | -5              | B                |
| 8          | 8         | -8              | 8                |
| D          | 13        | -3              | 3                |
| F          | 15        | -1              | 1                |

对于补码和无符号（练习题 2.28）非（negation）产生的位模式，你观察到什么？
对于无符号，位模式相同。
参见 [[第2章-信息的表示和处理#求反]]。


**2.34** 按照图 2-27 的风格填写下表，说明不同的 3 位数字乘法的结果。

| 模式  | $x$      | $y$      | $x \cdot y$ | 截断的 $x \cdot y$ |
| :-- | :------- | :------- | :---------- | :-------------- |
| 无符号 | [100] 4  | [101] 5  | [10100] 20  | [100] 4         |
| 补码  | [100] -4 | [101] -3 | [1100] 12   | [100] -4        |
| 无符号 | [010] 2  | [111] 7  | [1110] 14   | [110] 6         |
| 补码  | [010] 2  | [111] -1 | [1110] -2   | [110] -2        |
| 无符号 | [110] 6  | [110] 6  | [100100] 36 | [100] 4         |
| 补码  | [110] -2 | [110] -2 | [100] 4     | [100] -4        |
可见位模式上 **无符号** 和 **有符号** 表现相同。
参见 [[第2章-信息的表示和处理#有符号乘法]]。


**2.35** 给你一个任务，开发函数 `tmult_ok` 的代码，该函数会判断两个参数相乘是否会产生溢出。下面是你的解决方案：

```c
/* Determine whether arguments can be multiplied without overflow */
int tmult_ok(int x, int y) {
    int p = x*y;
    /* Either x is zero, or dividing p by x gives y */
    return !x || p/x == y;
}
````

你用 $x$ 和 $y$ 的很多值来测试这段代码，似乎都工作正常。你的同事挑战你，说：“如果我不能用减法来检验加法是否溢出（参见练习题 2.31），那么你怎么能用除法来检验乘法是否溢出呢？”

按照下面的思路，用数学推导来证明你的方法是对的。首先，证明 $x=0$ 的情况是正确的。另外，考虑 $w$ 位数字 $x(x \neq 0)$、$y$、$p$ 和 $q$，这里 $p$ 是 $x$ 和 $y$ 补码乘法的结果，而 $q$ 是 $p$ 除以 $x$ 的结果。

1. 说明 $x$ 和 $y$ 的整数乘积 $x \cdot y$，可以写成这样的形式：$x \cdot y = p + t 2^w$，其中 $t \neq 0$ 当且仅当 $p$ 的计算溢出。
    
2. 说明 $p$ 可以写成这样的形式：$p = x \cdot q + r$，其中 $|r| < |x|$。
    
3. 说明 $q = y$ 当且仅当 $r = t = 0$。

- 当 $x = 0$ 时，显然有 $TMult_{w}(0, x) = U2T_{w}(0 \cdot x \bmod 2^{w}) = 0$
- 当 $x \neq 0$ 时：
    1. $p = U2T_{w}(x \cdot y \bmod 2^{w})$
        1. 若没有溢出，也即 $x \cdot y < 2^{w}$ 时，显然有 $x \cdot y = p = p + t 2^{w} \ (t = 0)$；
        2. 若溢出，也即 $x \cdot y \geq 2^{w}$ 时，由模运算的性质有 $p' = x \cdot y - t' 2^{w} \ (t > 0)$，其中 $p' = p + p_{w - 1} 2^{w}$，有 $p = x \cdot y - (t' + p_{2 - 1}) 2^{w} = x \cdot y - t 2^{w}$，也即 $x \cdot y = p + t 2^{w} \ (t \neq 0)$
        3. 由此得知，$x \cdot y = p + t 2^{w}$，其中 $t \neq 0$ 当且仅当 $p$ 的计算溢出。
    2. 这是整数除法的定义。
    3. 假设 $q = y$，有 $x \cdot y = x \cdot y + r + t 2^{w}$，有 $r + t 2^{w} = 0$，则 $|r| < |x| \leq 2^{w} \implies |t 2^{w}| < 2^{w} \implies t = 0, r = 0$
    4. 当 $q = y$ 时 $t = 0$，由 1. 知 $p$ 的计算没有溢出。




**2.36** 对于数据类型 `int` 为 32 位的情况，设计一个版本的 `tmult_ok` 函数（练习题 2.35），使用 64 位精度的数据类型 `int64_t`，而不使用除法。

```c
int tmult_ok(int x, int y) {
    int64_t pll = (int64_t)x * y;
    return pll == (int)pll;
}
```



**2.37** 现在你有一个任务，当数据类型 `int` 和 `size_t` 都是 32 位的，修补上述旁注给出的 XDR 代码中的漏洞。你决定将待分配字节数设置为数据类型 `uint64_t`，来消除乘法溢出的可能性。你把原来对 `malloc` 函数的调用（第 9 行）替换如下：

```c
uint64_t asize =
    ele_cnt * (uint64_t) ele_size;
void *result = malloc(asize);
````

提醒一下，`malloc` 的参数类型是 `size_t`。

1. 这段代码对原始的代码有了哪些改进？
    乘法不会溢出，但是 `malloc` 还是当作无符号 32 位整数用。 
2. 你该如何修改代码来消除这个漏洞？
    ```c
    uint64_t asize = ele_cnt * (uint64_t) ele_size;
    size_t rsize = (size_t) asize;
    if (rsize != asize) {
        return NULL;
    }
    void *result = malloc(rsize);
    if (result == NULL) {
        return NULL;
    }
    ```


**2.38** 就像我们将在第 3 章中看到的那样，LEA 指令能够执行形如 (a << k) + b 的计算，这里 k 等于 0、1、2 或 3，而 b 等于 0 或者某个程序值。编译器常常用这条指令来执行常数因子乘法。例如，我们可以用 (a << 1) + a 来计算 3 * a。

考虑 b 等于 0 或者等于 a、k 为任意可能的值的情况，用一条 LEA 指令可以计算 a 的哪些倍数？

$a \cdot (2^{k} + 1)$ 和 $a \cdot 2^{k}$


**2.39** 对于位位置 $n$ 为最高有效位的情况，我们要怎样修改形式 B 的表达式(`(x << (n + 1)) - (x << m)`)？

`-(x << m)`


**2.40** 对于下面每个 $K$ 的值，找出只用指定数量的运算表达 $x * K$ 的方法，这里我们认为加法和减法的开销相当。除了我们已经考虑过的简单形式 A 和 B 原则，你可能会需要使用一些技巧。

| $K$ | 移位  | 加法 / 减法 | 表达式                     |
| :-: | :-: | :-----: | :---------------------- |
|  6  |  2  |    1    | (x << 3) - (x << 1)     |
| 31  |  1  |    1    | (x << 5) - x            |
| -6  |  2  |    1    | (x << 1) - (x << 3)     |
| 55  |  2  |    2    | (x << 6) - (x << 3) - x |



**2.41** 对于一组从位位置 $n$ 开始到位位置 $m$ 的连续的 1 ($n \ge m$)，我们看到可以产生两种形式的代码，A 和 B。编译器该如何决定使用哪一种呢？

假设加法和减法的代价相同
1. 当 $n = m$ 时，A 只产生 $1$ 次移位，B 产生 $2$ 次移位和 $1$ 次减法，故选 **A**。
2. 当 $n = m + 1$ 时，A 产生 $2$ 次移位和 $1$ 次减法，B 也是，选 **A 或 B**。
3. 当 $n > m + 1$ 时，A 产生不止 $2$ 次移位和不止 $1$ 次加法，选 **B**。



**2.42** 写一个函数 `div16`，对于整数参数 `x` 返回 `x/16` 的值。你的函数不能使用除法、模运算、乘法、任何条件语句（`if` 或者 `?:`）、任何比较运算符（例如 `<`、`>` 或 `==`）或任何循环。你可以假设数据类型 `int` 是 32 位长，使用补码表示，而右移是算术右移。

```c
int div16(int x) {
    return (x + (x >> 31 & 0xF)) >> 4;
}
```


**2.43** 在下面的代码中，我们省略了常数 $M$ 和 $N$ 的定义：

```c
#define M    /* Mystery number 1 */
#define N    /* Mystery number 2 */
int arith(int x, int y) {
    int result = 0;
    result = x*M + y/N; /* M and N are mystery numbers. */
    return result;
}
````

我们以某个 $M$ 和 $N$ 的值编译这段代码。编译器用我们讨论过的方法优化乘法和除法。下面是将产生出的机器代码翻译回 C 语言的结果：


```c
/* Translation of assembly code for arith */
int optarith(int x, int y) {
    int t = x;
    x <<= 5;
    x -= t;
    if (y < 0) y += 7;
    y >>= 3; /* Arithmetic shift */
    return x+y;
}
```

$M$ 和 $N$ 的值为多少？

1. $(x \ll 5) - x = x \cdot 2^{5} - x = 31 x \implies M = 31$
2. $y \gg 3 = \left\lfloor  \frac{y}{8} \right\rfloor \ (y \geq 0), (y + 7) \gg 3 = \left\lceil  \frac{y}{8}  \right\rceil \ (y < 0)$


**2.44** 假设我们在对有符号值使用补码运算的 32 位机器上运行代码。对于有符号值使用的是算术右移，而对于无符号值使用的是逻辑右移。变量的声明和初始化如下：

```c
int x = foo();    /* Arbitrary value */
int y = bar();    /* Arbitrary value */

unsigned ux = x;
unsigned uy = y;
````

对于下面每个 C 表达式，1) 证明对于所有的 x 和 y 值，它都为真（等于 1）；或者 2) 给出使得它为假（等于 0）的 x 和 y 的值：

A. `(x > 0) || (x-1 < 0)`
2)，$x = T_{min}$

B. `(x & 7) != 7 || (x<<29 < 0)`
1)，若 `(x & 7) == 7`，则 `x` 的末三位都为 `1`，`x << 29` 符号位为负数。

C. `(x * x) >= 0`
2)，`x = 0xFFFF`。

D. `x < 0 || -x <= 0`
1)，$|TMax| < |TMin|$。

E. `x > 0 || -x >= 0`
2)，$x = TMin$

F. `x+y == uy+ux`
1)，编码上等价

G. `x*~y + uy*ux == -x`
`(~y) + 1 == -y`
`x*~y == x * (-y - 1)`
编码上等价于 `x * (-y - 1) + x * y`


**2.45**　填写下表中的缺失的信息：

| 小数值             | 二进制表示   | 十进制表示  |
| :-------------- | :------ | :----- |
| $\frac{1}{8}$   | 0.001   | 0.125  |
| $\frac{3}{4}$   | 0.11    | 0.75   |
| $\frac{25}{16}$ | 1.1001  | 1.5625 |
| $\frac{43}{16}$ | 10.1011 | 2.6875 |
| $\frac{9}{8}$   | 1.001   | 1.125  |
| $\frac{47}{8}$  | 101.111 | 5.875  |
| $\frac{51}{16}$ | 11.0011 | 3.1875 |


**2.46**　浮点运算的不精确性能够产生灾难性的后果。1991 年 2 月 25 日，在第一次海湾战争期间，沙特阿拉伯的达摩地区设置的美国爱国者导弹，拦截伊拉克的飞毛腿导弹失败。飞毛腿导弹击中了美国的一个兵营，造成 28 名士兵死亡。美国总审计局(GAO)对失败原因做了详细的分析，并且确定底层的原因在于一个数字计算不精确。在这个练习中，你将重现总审计局分析的一部分。 ^236745

爱国者导弹系统中含有一个内置的时钟，其实现类似一个计数器，每 0.1 秒就加 1。为了以秒为单位来确定时间，程序将用一个 24 位的近似于 1/10 的二进制小数值来乘以这个计数器的值。特别地，1/10 的二进制表达式是一个无穷序列 $0.000110011[0011]\cdots_2$，其中，方括号里的部分是无限重复的。程序用值 $x$ 来近似地表示 0.1，$x$ 只考虑这个序列的二进制小数点右边的前 23 位：$x=0.00011001100110011001100$。（参考练习题 2.51，里面有关于如何能够更精确地近似表示 0.1 的讨论。）

A. $0.1-x$ 的二进制表示是什么？
$0.0000000000000000000000011[0011] \cdots_{2}$

B. $0.1-x$ 的近似的十进制值是多少？
$9.54 \times 10^{-8}$

C. 当系统初始启动时，时钟从 0 开始，并且一直保持计数。在这个例子中，系统已经运行了大约 100 个小时。程序计算出的时间和实际的时间之差为多少？
$0.343$

D. 系统根据一枚来袭导弹的速率和它最后被雷达侦测到的时间，来预测它将在哪里出现。假定飞毛腿的速率大约是 2000 米每秒，对它的预测偏差了多少？
$688$

通过一次读取时钟得到的绝对时间中的轻微错误，通常不会影响跟踪的计算。相反，它应该依赖于两次连续的读取之间的相对时间。问题是爱国者导弹的软件已经升级，可以使用更精确的函数来读取时间，但不是所有的函数调用都用新的代码替换了。结果就是，跟踪软件一次读取用的是精确的时间，而另一次读取用的是不精确的时间。


**2.47**　假设一个基于 IEEE 浮点格式的 5 位浮点表示，有 1 个符号位、2 个阶码位($k=2$)和两个小数位($n=2$)。阶码偏置量是 $2^{2-1}-1=1$。

下表中列举了这个 5 位浮点表示的全部非负取值范围。使用下面的条件，填写表格中的空白项：

- $e$：假定阶码字段是一个无符号整数所表示的值。
- $E$：偏置之后的阶码值。
- $2^E$：阶码的权重。
- $f$：小数值。
- $M$：尾数的值。
- $2^E \times M$：该数(未归约的)小数值。
- $V$：该数归约后的小数值。
- 十进制：该数的十进制表示。

写出 $2^E$、$f$、$M$、$2^E \times M$ 和 $V$ 的值，要么是整数(如果可能的话)，要么是形如 $\frac{x}{y}$ 的小数，这里 $y$ 是 2 的幂。标注为“—”的条目不用填。

|    位    | $e$ | $E$ | $2^E$ |      $f$      |      $M$      | $2^E \times M$ |      $V$      |  十进制   |
| :-----: | :-: | :-: | :---: | :-----------: | :-----------: | :------------: | :-----------: | :----: |
| 0 00 00 | $0$ | $0$ |  $1$  |      $0$      |      $0$      |      $0$       |      $0$      |  $0$   |
| 0 00 01 | $0$ | $0$ |  $1$  | $\frac{1}{4}$ | $\frac{1}{4}$ | $\frac{1}{4}$  | $\frac{1}{4}$ | $0.25$ |
| 0 00 10 | $0$ | $0$ |  $1$  | $\frac{2}{4}$ | $\frac{2}{4}$ | $\frac{2}{4}$  | $\frac{1}{2}$ | $0.5$  |
| 0 00 11 | $0$ | $0$ |  $1$  | $\frac{3}{4}$ | $\frac{3}{4}$ | $\frac{3}{4}$  | $\frac{3}{4}$ | $0.75$ |
| 0 01 00 |  1  | $0$ |  $1$  |      $0$      | $\frac{4}{4}$ | $\frac{4}{4}$  | $\frac{1}{1}$ |  $1$   |
| 0 01 01 |  1  | $0$ |   1   | $\frac{1}{4}$ | $\frac{5}{4}$ | $\frac{5}{4}$  | $\frac{5}{4}$ | $1.25$ |
| 0 01 10 | $1$ | $0$ |  $1$  | $\frac{2}{4}$ | $\frac{6}{4}$ | $\frac{6}{4}$  | $\frac{3}{2}$ | $1.5$  |
| 0 01 11 | $1$ | $0$ |  $1$  | $\frac{3}{4}$ | $\frac{7}{4}$ | $\frac{7}{4}$  | $\frac{7}{4}$ |  1.75  |
| 0 10 00 | $2$ | $1$ |  $2$  |      $0$      | $\frac{4}{4}$ | $\frac{8}{4}$  | $\frac{2}{1}$ |  $2$   |
| 0 10 01 | $2$ | $1$ |  $2$  | $\frac{1}{4}$ | $\frac{5}{4}$ | $\frac{10}{4}$ | $\frac{5}{2}$ | $2.5$  |
| 0 10 10 | $2$ | $1$ |  $2$  | $\frac{2}{4}$ | $\frac{6}{4}$ | $\frac{12}{4}$ | $\frac{3}{1}$ |   3    |
| 0 10 11 | $2$ | $1$ |  $2$  | $\frac{3}{4}$ | $\frac{7}{4}$ | $\frac{14}{4}$ | $\frac{7}{2}$ |  3.5   |
| 0 11 00 |  —  |  —  |   —   |       —       |       —       |       —        | $\frac{4}{1}$ |  $4$   |
| 0 11 01 |  —  |  —  |   —   |       —       |       —       |       —        | $\frac{5}{1}$ |  $5$   |
| 0 11 10 |  —  |  —  |   —   |       —       |       —       |       —        | $\frac{6}{1}$ |  $6$   |
| 0 11 11 |  —  |  —  |   —   |       —       |       —       |       —        | $\frac{7}{1}$ |  $7$   |

**2.48**　正如在 [[#^c944db|练习题 2.6]] 中提到的，整数 3 510 593 的十六进制表示为 0x00359141，而单精度浮点数 3510593.0 的十六进制表示为 0x4A564504。推导出这个浮点表示，并解释整数和浮点数表示的位之间的关系。

$3510593.0 = 1.101011001000101000001 \times 2^{21}$
$f = 0.1010\dots$ 有 $frac$ 的二进制 `10101100100010100000100`
$bias = 2^{8 - 1} - 1 = 127$
$E = 21$ 有 $exp = E + bias = 21 + 127 = 148 = 10010100_{2}$
则 $3510593.0$ 的二进制表示为 `0 10010100 10101100100010100000100`
而整数 $3510593$ 的二进制表示为 `1101011001000101000001`。
其中浮点数的位模式中 $frac$ 段和整数位模式中除首位的其他位相等。
```
3510593.0 = 0 10010100 10101100100010100000100
                       *********************
3510593   =           1101011001000101000001
```


**2.49** ^e70a2b
1. 对于一种具有 $n$ 位小数的浮点格式，给出不能准确描述的最小正整数的公式(因为要想准确表示它需要 $n+1$ 位小数)。假设阶码字段长度 $k$ 足够大，可以表示的阶码范围不会限制这个问题。
    算上隐含的前导位之后，该格式能表示的有效精度位数为 $n + 1$ 位。当整数的二进制为 `10000...1` 即 $2^{n + 1} + 1$ 时，需要 $n + 2$ 位的有效位，也即 $n + 1$ 位小数。

2. 对于单精度格式($n=23$)，这个整数的数字值是多少？
    $2^{23+1}+1 = 16777217$


**2.50**　根据舍入到偶数规则，说明如何将下列二进制小数值舍入到最接近的二分之一（二进制小数点右边 1 位）。对每种情况，给出舍入前后的数字值。

A. $10.010_2$
$10.0_{2}$

B. $10.011_2$
$10.1_{2}$

C. $10.110_2$
$11.0_{2}$

D. $11.001_2$
$11.0_{2}$


**2.51**　在 [[#^236745|练习题 2.46]] 中我们看到，爱国者导弹软件将 0.1 近似表示为 $x=0.00011001100110011001100_2$。假设使用 IEEE 舍入到偶数方式来确定 0.1 的二进制小数点右边 23 位的近似表示 $x'$。

A. $x'$ 的二进制表示是什么？
$0.00011 00110 01100 11001 101_{2}$

B. $x'-0.1$ 的十进制表示的近似值是什么？
$0.00000 00000 00000 00000 000 [0011] = 0.0[0011] \times 2^{-22} = 0.1 \times 2^{-22} \approx 0.086$


C. 运行 100 小时后，计算时钟值会有多少偏差？
$0.086$

D. 该程序对飞毛腿导弹位置的预测会有多少偏差？
$171.7$


**2.52**　考虑下列基于 IEEE 浮点格式的 7 位浮点表示。两个格式都没有符号位——它们只能表示非负的数字。

1. **格式 A**
   - 有 $k=3$ 个阶码位。阶码的偏置值是 3。
   - 有 $n=4$ 个小数位。

2. **格式 B**
   - 有 $k=4$ 个阶码位。阶码的偏置值是 7。
   - 有 $n=3$ 个小数位。

下面给出了一些格式 A 表示的位模式，你的任务是将它们转换成格式 B 中最接近的值。如果需要，请使用舍入到偶数的舍入原则。另外，给出由格式 A 和格式 B 表示的位模式对应的数字的值。给出整数(例如 17)或者小数(例如 17/64)。

| 格式 A     |       | 格式 B     |      |
| :------- | :---- | :------- | :--- |
| 位        | 值     | 位        | 值    |
| 011 0000 | 1     | 0111 000 | 1    |
| 101 1110 | 15/2  | 1010 111 | 15/2 |
| 010 1001 | 25/32 | 0110 100 | 3/4  |
| 110 1111 | 31/2  | 1011 000 | 16   |
| 000 0001 | 1/64  | 0001 000 | 1/64 |


**2.53**　完成下列宏定义，生成双精度值 $+\infty$、$-\infty$ 和 $0$：

```c
#define POS_INFINITY
#define NEG_INFINITY
#define NEG_ZERO
```

不能使用任何 include 文件（例如 `math.h`），但你能利用这样一个事实：双精度能够表示的最大的有限数，大约是 $1.8 \times 10^{308}$。

```c
#define POS_INFINITY 1e400
#define NEG_INFINITY -POS_INFINITY
#define NEG_ZERO -1.0/NEG_INFINITY
```


**2.54** 假定变量 x、f 和 d 的类型分别是 int、float 和 double。除了 f 和 d 都不能等于 +∞、−∞ 或者 NaN，它们的值是任意的。对于下面每个 C 表达式，证明它总是为真（也就是求值为 1），或者给出一个使表达式不为真的值（也就是求值为 0）。

A. `x == (int) (double) x`
真，double 范围更大

B. `x == (int) (float) x`
假，$TMax$

C. `d == (double) (float) d`
假，$1\times 10^{40}$，double 转 float 会溢出或者发生舍入。

D. `f == (float) (double) f`
真，double 的精度和范围更大。

E. `f == -(-f)`
真，浮点数取反只是取反符号位。

F. `1.0/2 == 1/2.0`
真，隐式类型转换。

G. `d*d >= 0.0`
真，虽然可能会溢出。

H. `(f+d)-f == d`
假，`f = 1.0e20`, `d = 1.0`，会发生“对阶”。