---
tags:
  - CSAPP
---
笔记：[[第2章-信息的表示和处理]]

**2.55** 在你能够访问的不同机器上，使用 show_bytes(文件 show-bytes.c)编译并运行示例代码。确定这些机器使用的字节顺序。
```c
/*
 * show-bytes.c
 */

#include <stdio.h>

typedef unsigned char* byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
  size_t i;
  for (i = 0; i < len; i++) {
    printf(" %.2x", start[i]);
  }
  printf("\n");
}

void show_int(int x) {
  show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x) {
  show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void* x) {
  show_bytes((byte_pointer) &x, sizeof(void*));
}

void test_show_bytes(int val) {
  int ival = val;
  float fval = (float) ival;
  int* pval = &ival;

  show_int(ival);
  show_float(fval);
  show_pointer(pval);
}

int main(int argc, char* argv[]) {
  int test_num = 328;

  test_show_bytes(test_num);
  return 0;
}
```

```bash
./show_bytes
 48 01 00 00
 00 00 a4 43
 1c 60 86 bb fe 7f 00 00
```

**2.56** 试着用不同的示例值来运行 show_bytes 的代码。

```c
int test_num = 1024;
```

```bash
./show_bytes
 00 04 00 00
 00 00 80 44
 fc 7a 29 41 fe 7f 00 00
```

**2.57** 编写程序 show_short、show_long 和 show_double，它们分别打印类型为 short、long 和 double 的 C 语言对象的字节表示。请试着在几种机器上运行。

```c
void show_short(short x) { 
    show_bytes((byte_pointer) &x, sizeof(short)); 
}
void show_long(long x) {
    show_bytes((byte_pointer) &x, sizeof(long));
}
void show_double(double x) {
    show_bytes((byte_pointer) &x, sizeof(double));
}
```


**2.58** 编写过程 is_little_endian，当在小端法机器上编译和运行时返回 1，在大端法机器上编译运行时则返回 0。这个程序应该可以运行在任何机器上，无论机器的字长是多少。
```c
#include <stdio.h>

typedef unsigned char *byte_pointer;

int is_little_endian() {
    int x = 1;
    byte_pointer p = (byte_pointer)&x;
    return (int)(*p);
}

int main() {
    printf("%d", is_little_endian());
    return 0;
}
```


**2.59** 编写一个 C 表达式，它生成一个字，由 x 的最低有效字节和 y 中剩下的字节组成。对于运算数 x=0x89ABCDEF 和 y=0x76543210，就得到 0x765432EF。
```c
(x & 0x000000FF) | (y & 0xFFFFFF00)
```


**2.60** 假设我们将一个 w 位的字中的字节从 0(最低位)到 w/8-1(最高位)编号。写出下面 C 函数的代码，它会返回一个无符号值，其中参数 x 的字节 i 被替换成字节 b：

  ```c
  unsigned replace_byte (unsigned x, int i, unsigned char b);
  ```

  以下示例，说明了这个函数该如何工作：

  replace_byte(0x12345678, 2, 0xAB) --> 0x12AB5678  
  replace_byte(0x12345678, 0, 0xAB) --> 0x123456AB

```c
unsigned replace_byte(unsigned x, int i, unsigned char b) {
    return (x & ~(0xFFU << (i << 3))) | ((unsigned)b << (i << 3));
}
```


**2.61** 写一个 C 表达式，在下列描述的条件下产生 1，而在其他情况下得到 0。假设 x 是 int 类型。

A. x 的任何位都等于 1。

B. x 的任何位都等于 0。

C. x 的最低有效字节中的位都等于 1。

D. x 的最高有效字节中的位都等于 0。

代码应该遵循位级整数编码规则，另外还有一个限制，你不能使用相等(\==)和不相等(!=)测试。

A. `!~x`
B. `!x`
C. `!(~x & 0xFF)`
D. `!(x >> ((sizeof(int) - 1) << 3) & 0xFF)`


**2.62** 编写一个函数 int_shifts_are_arithmetic()，在对 int 类型的数使用算术右移的机器上运行时这个函数生成 1，而其他情况下生成 0。你的代码应该可以运行在任何字长的机器上。在几种机器上测试你的代码。

```c
int int_shifts_are_arithmetic() {
    return (-1 >> 1) == -1;
}
```


**2.63** 将下面的 C 函数代码补充完整。函数 srl 用算术右移(由值 xsra 给出)来完成逻辑右移，后面的其他操作不包括右移或者除法。函数 sra 用逻辑右移(由值 xsrl 给出)来完成算术右移，后面的其他操作不包括右移或者除法。可以通过计算 8*sizeof(int)来确定数据类型 int 中的位数 w。位移量 k 的取值范围为 0～w-1。

```c
unsigned srl(unsigned x, int k) {
    /* Perform shift arithmetically */
    unsigned xsra = (int) x >> k;
    .
    .
    .
    .
    .
}

int sra(int x, int k) {
    /* Perform shift logically */
    int xsrl = (unsigned) x >> k;
    .
    .
    .
    .
    .
}
```

```c
unsigned srl(unsigned x, int k) {
    unsigned xsra = (int) x >> k;
    unsigned w = sizeof(int) << 3;
    return ((2 << w - k - 1) - 1) & xsra;
}

int sra(int x, int k) {
    int xsrl = (unsigned) x >> k;
    unsigned w = sizeof(int) << 3;
    // all 1 if x < 0
    int signMask = !(x & (1 << w - 1)) - 1;
    return xsrl | (signMask & ~((2 << w - k - 1) - 1));
}
```


**2.64** 写出代码实现如下函数：

```c
/* Return 1 when any odd bit of x equals 1; 0 otherwise.
   Assume w=32 */
int any_odd_one(unsigned x);
```

函数应该遵循位级整数编码规则，不过你可以假设数据类型 int 有 w=32 位。

```c
int any_odd_one(unsigned x) {
    return x & 0xAAAAAAAA;
}
```

**2.65** 写出代码实现如下函数：

```c
/* Return 1 when x contains an odd number of 1s; 0 otherwise.
   Assume w=32 */
int odd_ones(unsigned x);
```

函数应该遵循位级整数编码规则，不过你可以假设数据类型 int 有 w=32 位。

你的代码最多只能包含 12 个算术运算、位运算和逻辑运算。

```c
int odd_ones(unsigned x) {
    x ^= x >> 16;
    x ^= x >> 8;
    x ^= x >> 4;
    x ^= x >> 2;
    x ^= x >> 1;
    return (int)(x & 1);
}
```

**2.66** 写出代码实现如下函数：

```c
/*
 * Generate mask indicating leftmost 1 in x. Assume w=32.
 * For example, 0xFF00 -> 0x8000, and 0x6600 --> 0x4000.
 * If x = 0, then return 0.
 */
int leftmost_one(unsigned x);
```

函数应该遵循位级整数编码规则，不过你可以假设数据类型 int 有 w=32 位。

你的代码最多只能包含 15 个算术运算、位运算和逻辑运算。

提示：先将 x 转换成形如 [0...011...1] 的位向量。

```c
int leftmost_one(unsigned x) {
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    return x ^ (x >> 1);
}
```


**2.67** 给你一个任务，编写一个过程 `int_size_is_32()`，当在一个 int 是 32 位的机器上运行时，该程序产生 1，而其他情况则产生 0。不允许使用 sizeof 运算符。下面是开始时的尝试：

```c
1    /* The following code does not run properly on some machines */
2    int bad_int_size_is_32() {
3        /* Set most significant bit (msb) of 32-bit machine */
4        int set_msb = 1 << 31;
5        /* Shift past msb of 32-bit word */
6        int beyond_msb = 1 << 32;
7    
8        /* set_msb is nonzero when word size >= 32
9           beyond_msb is zero when word size <= 32 */
10       return set_msb && !beyond_msb;
11   }
```

当在 SUN SPARC 这样的 32 位机器上编译并运行时，这个过程返回的却是 0。下面的编译器信息给了我们一个问题的指示：

warning: left shift count >= width of type

A. 我们的代码在哪个方面没有遵守 C 语言标准？
左移位数大于类型位数是未定义行为。

B. 修改代码，使得它在 int 至少为 32 位的任何机器上都能正确地运行。
```c
int int_size_is_32() {
    int set_msb = 1 << 31;
    int beyond_msb = 2 << 31;
    return set_msb && !beyond_msb;
}
```

C. 修改代码，使得它在 int 至少为 16 位的任何机器上都能正确地运行。
```c
int int_size_is_32() {
    int set_msb = ((1 << 15) << 15) << 1;
    int beyond_msb = ((1 << 15) << 15) << 2;
    return set_msb && !beyond_msb;
}
```

**2.68** 写出具有如下原型的函数的代码：

```c
/*
 * Mask with least significant n bits set to 1
 * Examples: n = 6 --> 0x3F, n = 17 --> 0x1FFFF
 * Assume 1 <= n <= w
 */
int lower_one_mask(int n);
```

函数应该遵循位级整数编码规则。要注意 $n=w$ 的情况。
```c
int lower_one_mast(int n) {
    return ((1 << (n - 1)) << 1) - 1;
}
```

**2.69** 写出具有如下原型的函数的代码：

```c
/*
 * Do rotating left shift. Assume 0 <= n < w
 * Examples when x = 0x12345678 and w = 32:
 *   n=4 -> 0x23456781, n=20 -> 0x67812345
 */
unsigned rotate_left(unsigned x, int n);
```

函数应该遵循位级整数编码规则。要注意 $n=0$ 的情况。

```c
unsigned rotate_left(unsigned x, int n) {
    return (x >> (31 - n) >> 1) | (x << n);
}
```


**2.70** 写出具有如下原型的函数的代码：

```c
/*
 * Return 1 when x can be represented as an n-bit, 2's-complement
 * number; 0 otherwise
 * Assume 1 <= n <= w
 */
int fits_bits(int x, int n);
```

函数应该遵循位级整数编码规则。

```c
int fits_bits(int x, int n) {
    int shift = 32 - n;
    return (x << shift >> shift) == x;
}
```


**2.71** 你刚刚开始在一家公司工作，他们要实现一组过程来操作一个数据结构，要将 4 个有符号字节封装成一个 32 位 unsigned。一个字中的字节从 0(最低有效字节)编号到 3(最高有效字节)。分配给你的任务是：为一个使用补码运算和算术右移的机器编写一个具有如下原型的函数：

```c
/* Declaration of data type where 4 bytes are packed
   into an unsigned */
typedef unsigned packed_t;

/* Extract byte from word. Return as signed integer */
int xbyte(packed_t word, int bytenum);
```

也就是说，函数会抽取出指定的字节，再把它符号扩展为一个 32 位 int。

你的前任(因为水平不够高而被解雇了)编写了下面的代码：

```c
/* Failed attempt at xbyte */
int xbyte(packed_t word, int bytenum)
{
    return (word >> (bytenum << 3)) & 0xFF;
}
```

A. 这段代码错在哪里？
没有进行符号扩展。
B. 给出函数的正确实现，只能使用左右移位和一个减法。
```c
int xbyte(packed_t word, int bytenum) {
    return (int) word  << (3 - bytenum) << 3 >> 24;
}
```


**2.72** 给你一个任务，写一个函数，将整数 val 复制到缓冲区 buf 中，但是只有当缓冲区中有足够可用的空间时，才执行复制。

你写的代码如下：

```c
/* Copy integer into buffer if space is available */
/* WARNING: The following code is buggy */
void copy_int(int val, void *buf, int maxbytes) {
    if (maxbytes-sizeof(val) >= 0)
        memcpy(buf, (void *) &val, sizeof(val));
}
```

这段代码使用了库函数 memcpy。虽然在这里用这个函数有点刻意，因为我们只是想复制一个 int，但是它说明了一种复制较大数据结构的常见方法。

你仔细地测试了这段代码后发现，哪怕 maxbytes 很小的时候，它也能把值复制到缓冲区中。

A. 解释为什么代码中的条件测试总是成功。提示：sizeof 运算符返回类型为 size_t 的值。
隐式类型转换，`maxbytes-sizeof(val)` 恒大于等于 0。

B. 你该如何重写这个条件测试，使之工作正确。
`if (maxbytes >= sizeof(val))`


**2.73** 写出具有如下原型的函数的代码：

```c
/* Addition that saturates to TMin or TMax */
int saturating_add(int x, int y);
```


同正常的补码加法溢出的方式不同，当正溢出时，饱和加法返回 TMax，负溢出时，返回 TMin。饱和运算常常用在执行数字信号处理的程序中。

你的函数应该遵循位级整数编码规则。

```c
int saturating_add(int x, int y) {
    int w = sizeof(int) << 3;
    int sum = (int)((unsigned)x + (unsigned)y);
    int xs = x >> (w - 1);
    int ys = y >> (w - 1);
    int ss = sum >> (w - 1);
    int po = !(!xs && !ys && ss) - 1;
    int no = !(xs && ys && !ss) - 1;
    return (po & INT_MAX) | (no & INT_MIN) | (sum & ~(po | no));
}
```

**2.74** 写出具有如下原型的函数的代码：

```c
/* Determine whether arguments can be subtracted without overflow */
int tsub_ok(int x, int y);
```

如果计算 x-y 不溢出，这个函数就返回 1。

```c
int tsub_ok(int x, int y) {
    int w = sizeof(int) << 3;
    int sub = x - y;
    int xs = x >> (w - 1);
    int ys = y >> (w - 1);
    int ss = sub >> (w - 1);
    return !((xs != ys) && (ys == ss));
}
```


**2.75** 假设我们想要计算 $x \cdot y$ 的完整的 $2w$ 位表示，其中，$x$ 和 $y$ 都是无符号数，并且运行在数据类型 `unsigned` 是 $w$ 位的机器上。乘积的低 $w$ 位能够用表达式 `x*y` 计算，所以，我们只需要一个具有下列原型的函数：

```c
unsigned unsigned_high_prod(unsigned x, unsigned y);
```

这个函数计算无符号变量 $x \cdot y$ 的高 $w$ 位。

我们使用一个具有下面原型的库函数：

```c
int signed_high_prod(int x, int y);
```

它计算在 $x$ 和 $y$ 采用补码形式的情况下，$x \cdot y$ 的高 $w$ 位。编写代码调用这个过程，以实现用无符号数为参数的函数。验证你的解答的正确性。

提示：看看等式(2.18)的推导中，有符号积 $x \cdot y$ 和无符号积 $x' \cdot y'$ 之间的关系。

```c
unsigned unsigned_high_prod(unsigned x, unsigned y) {
    unsigned w = sizeof(signed) << 3;
    int xs = (int) x >> (w - 1);
    int ys = (int) y >> (w - 1);
    return (unsigned) signed_high_prod((int) x, (int) y) + (xs & y) + (ys & x);
}
```


**2.76** 库函数 calloc 有如下声明：

```c
void *calloc(size_t nmemb, size_t size);
```

根据库文档："函数 calloc 为一个数组分配内存，该数组有 nmemb 个元素，每个元素为 size 字节。内存设置为 0。如果 nmemb 或 size 为 0，则 calloc 返回 NULL。"

编写 calloc 的实现，通过调用 malloc 执行分配，调用 memset 将内存设置为 0。你的代码应该没有任何由算术溢出引起的漏洞，且无论数据类型 size_t 用多少位表示，代码都应该正常工作。

作为参考，函数 malloc 和 memset 声明如下：

```c
void *malloc(size_t size);
void *memset(void *s, int c, size_t n);
```


```c
void *calloc(size_t nmemb, size_t size) {
    if (!(nmemb || size)) {
        return NULL;
    }
    void *arr = malloc(nmemb * size);
    memset(arr, 0x00, nmemb * size);
    return arr;
}
```


**2.77** 假设我们有一个任务：生成一段代码，将整数变量 x 乘以不同的常数因子 K。为了提高效率，我们想只使用 +、- 和 << 运算。对于下列 K 的值，写出执行乘法运算的 C 表达式，每个表达式中最多使用 3 个运算。

A. K=17
`(x << 4) + x`

B. K=-7
`x - (x << 3)`

C. K=60
`(x << 6) - (x << 2)`

D. K=-112
`(x << 4) - (x << 7)`


**2.78** 写出具有如下原型的函数的代码：
```c
/* Divide by power of 2. Assume 0 <= k < w-1 */
int divide_power2(int x, int k);
```
该函数要用正确的舍入方式计算 $x/2^k$，并且应该遵循位级整数编码规则。

```c
int divide_power2(int x, int k) {
    int w = sizeof(int) << 3;
    return (x + ((x >> (w - 1)) & ((1 << k) - 1))) >> k;
}
```


**2.79** 写出函数 `mul3div4` 的代码，对于整数参数 `x`，计算 `3*x/4`，但是要遵循位级整数编码规则。你的代码计算 `3*x` 也会产生溢出。

```c
int mul3div4(int x) {
    int w = sizeof(int) << 3;
    x = (x << 2) - x;
    x = (x + (x >> (w - 1) & 0x3)) >> 2;
    return x;
}
```


**2.80** 写出函数 `threefourths` 的代码，对于整数参数 `x`，计算 $3/4x$ 的值，向零舍入。它不会溢出。函数应该遵循位级整数编码规则。
```c
int threefourths(int x) {
    int w = sizeof(int) << 3;
    int bias = x >> (w - 1) & 0x3;
    int q = (x + bias) >> 2;
    int r = x - (q << 2);
    q = (q << 1) + q;
    r = (r << 1) + r;
    r = (r + bias) >> 2;
    return q + r;
}
```


**2.81** 编写 C 表达式产生如下位模式，其中 $a^k$ 表示符号 $a$ 重复 $k$ 次。假设一个 $w$ 位的数据类型。代码可以包含对参数 `j` 和 `k` 的引用，它们分别表示 $j$ 和 $k$ 的值，但是不能使用表示 $w$ 的参数。

A. $1^{w-k}0^k$
`(~0) << k`

B. $0^{w-k-j}1^k0^j$
`(1 << (j + k)) - (1 << j)`


***2.82*** 我们在一个 int 类型值为 32 位的机器上运行程序。这些值以补码形式表示，而且它们都是算术右移的。unsigned 类型的值也是 32 位的。

我们产生随机数 x 和 y，并且把它们转换成无符号数，显示如下：

```c
/* Create some arbitrary values */
int x = random();
int y = random();
/* Convert to unsigned */
unsigned ux = (unsigned) x;
unsigned uy = (unsigned) y;
```

对于下列每个 C 表达式，你要指出表达式是否总是为 1。如果它总是为 1，那么请描述其中的数学原理。否则，列举出一个使它为 0 的参数示例。

A. `(x < y) == (-x > -y)`
$x = TMin$ 时，$x$ 的加法逆元是其本身

B. `((x+y)<<4)+y-x==17*y+15*x`
模意义下同余

C. `~x+~y+1==~(x+y)`
$-x = \sim x + 1$，则左式为 $-x - y - 1$，右式为 $-(x + y) - 1$，数学上相等。

D. `(ux-uy)==-(unsigned)(y-x)`
编码上等价，隐式类型转换后相等

E. `((x>>2)<<2)<=x`
低位权重恒为正


**2.83** 一些数字的二进制表示是由形如 0.y y y y y y…的无穷串组成的，其中 y 是一个 k 位的序列。例如，$\frac{1}{3}$ 的二进制表示是 $0.01010101\cdots(y=01)$，而 $\frac{1}{5}$ 的二进制表示是 $0.001100110011\cdots(y=0011)$。

A. 设 $Y=B2U_k(y)$，也就是说，这个数具有二进制表示 y。给出一个由 Y 和 k 组成的公式表示这个无穷串的值。

提示：请考虑将二进制小数点右移 k 位的结果。

$2^{k} x = Y.yyyyy\dots = Y + x \implies x = \frac{Y}{2^{k} - 1}$

B. 对于下列的 y 值，串的数值是多少？

   (a) 101
    $\frac{5}{7}$

   (b) 0110
    $\frac{6}{15}$

   (c) 010011
   $\frac{19}{63}$


**2.84** 填写下列程序的返回值，这个程序测试它的第一个参数是否小于或者等于第二个参数。假定函数f2u返回一个无符号32位数字，其位表示与它的浮点参数相同。你可以假设两个参数都不是NaN。两种0，+0和-0被认为是相等的。
```c

int float_le(float x, float y) {
    unsigned ux = f2u(x);
    unsigned uy = f2u(y);

    /* Get the sign bits */
    unsigned sx = ux >> 31;
    unsigned sy = uy >> 31;

    /* Give an expression using only ux, uy, sx, and sy */
    return (ux << 1) == (uy << 1)       // ux == uy == 0
        || sx && !sy                // x < 0 && y >= 0
        || !sx && !sy && ux <= uy   // x >= 0 && y >= 0
        || sx && sy && ux >= uy;
}
```


**2.85** 给定一个浮点格式，有 k 位指数和 n 位小数，对于下列数，写出阶码 E、尾数 M、小数 f 和值 V 的公式。另外，请描述其位表示。

A. 数7.0。
$7.0 = 1.11_{2} \times 2^{2}$ 则 $E = 2, M = \frac{7}{4}, f = \frac{3}{4}, V = 7$
$bias = 2^{k - 1} - 1 \implies exp = E + bias = 2^{k - 1} + 1 = 100\dots1_2$ 其中有 $k - 2$ 个零。
$frac = 110\dots0_{2}$ 其中有 $n - 2$ 个零。
符号位为 $0$


B. 能够被准确描述的最大奇整数。
$V = 2^{n + 1} - 1$
$E = n, M = 2 - 2^{-n}$
则小数位全为 $0$ 指数为为 $bias + n = 2^{k - 1} - 1 + n$

C. 最小的规格化数的倒数。
最小的规格化数为指数位 $exp = 000\dots1_{2} \implies E = exp - bias = 2 - 2^{k - 1}$ 小数为 $M = 1.0000_{2}$
有 $V = 1.0_{2} \times 2^{2 - 2^{k - 1}}$
倒数为 $\frac{1}{V} = 2^{2^{k - 1} - 2}$
指数位 $E' = 2^{2^{k - 1} - 2} \implies exp' = E' + bias = 2^{k} - 3$，小数位不变
指数位 $11\dots 101_{2}$ 小数位 $00\dots 0$

**2.86** 与 Intel 兼容的处理器也支持“扩展精度”浮点形式，这种格式具有 80 位字长，被分成 1 个符号位、 $k = 15$ 个阶码位、1个单独的整数位和 $n = 63$ 个小数位。整数位是IEEE浮点表示中隐含位的显式副本。也就是说，对于规格化的值它等于1，对于非规格化的值它等于0。填写下表，给出用这种格式表示的一些“有趣的”数字的近似值。

| 描述        | 值                           | 十进制                     |
| :-------- | :-------------------------- | :---------------------- |
| 最小的正非规格化数 | `0x00000 00000 00000 00001` | $2^{-16445}$            |
| 最小的正规格化数  | `0x00018 00000 00000 00000` | $2^{-16382}$            |
| 最大的规格化数   | `0x7FFEF FFFFF FFFFF FFFFF` | $2^{16384} - 2^{16320}$ |

将数据类型声明为 long double，就可以把这种格式用于为与 Intel 兼容的机器编译 C 程序。但是，它会强制编译器以传统的 8087 浮点指令为基础生成代码。由此产生的程序很可能会比数据类型为 float 或 double 的情况慢上许多。

**2.87** 2008版IEEE浮点标准，即IEEE754-2008，包含了一种16位的“半精度”浮点格式。它最初是由计算机图形公司设计的，其存储的数据所需的动态范围要高于16位整数可获得的范围。这种格式具有1个符号位、5个阶码位 $(k = 5)$ 和10个小数位 $(n = 10)$。阶码偏置量是 $2^{5 - 1} - 1 = 15$。

对于每个给定的数，填写下表。每一列的含义如下：

- **Hex**：编码形式的4个十六进制数字
- **M**：尾数的值，形如 $x$ 或 $\frac{x}{y}$，其中 $x$ 是整数，$y$ 是2的整数幂（例如：$0$、$\frac{67}{64}$、$\frac{1}{256}$）
- **E**：阶码的整数值
- **V**：所表示的数字值，使用 $x$ 或 $x \times 2^{z}$ 表示，其中 $x$ 和 $z$ 都是整数
- **D**：(可能近似的)数值，用 `printf` 的格式规范 `%f` 打印

**例子**：为了表示数 $\frac{7}{8}$，我们有 $s = 0$，$M = \frac{7}{4}$ 和 $E = -1$。因此这个数的阶码字段为 $01110_{2}$（十进制值 $15 - 1 = 14$），尾数字段为 $1100000000_{2}$，得到一个十六进制的表示 `3B00`。其数值为 `0.875`。

标记为"—"的条目不用填写。

| 描述            | Hex  | M         | E   | V                     | D        |
| :------------ | :--- | :-------- | :-- | :-------------------- | :------- |
| -0            | 8000 | 0         | 0   | -0                    | -0.0     |
| 最小的>2的值       | 4001 | 1025/1024 | 1   | 1025/512              | 2.001953 |
| 512           | 6000 | 1         | 9   | 512                   | 512.0    |
| 最大的非规格化数      | 03FF | 1023/1024 | -14 | $1023 \times 2^{-24}$ | 0.000000 |
| -∞            | FC00 | -         | -   | -∞                    | -∞       |
| 十六进制表示为3BB0的数 | 3BB0 | 1968/1024 | -1  | 1968/2048             | 0.960938 |

**2.88** 考虑下面两个基于 IEEE 浮点格式的 9 位浮点表示。
1. 格式A
- 有一个符号位。
- 有 $k=5$ 个阶码位。阶码偏置量是15。
- 有 n=3 个小数位。
2. 格式B
- 有一个符号位。
- 有 k=4 个阶码位。阶码偏置量是7。
- 有 n=4 个小数位。
下面给出了一些格式A表示的位模式，你的任务是把它们转换成最接近的格式B表示的值。如果需要舍入，你要向 $+\infty$ 舍入。另外，给出用格式A和格式B表示的位模式对应的值。要么是整数（例如17），要么是小数（例如 $17/64$ 或 $17/2^6$）。

| 格式A       |                    | 格式B         |                   |
| :-------- | :----------------- | :---------- | :---------------- |
| 位         | 值                  | 位           | 值                 |
| 101110001 | $\frac{-9}{16}$    | 101100010   | $\frac{-9}{16}$   |
| 010110101 | $208$              | 011101010   | $208$             |
| 100111110 | $-\frac{7}{1024}$  | 100000111   | -$\frac{7}{1024}$ |
| 000000101 | $\frac{5}{131072}$ | 000000001   | $\frac{1}{1024}$  |
| 111011000 | $-4096$            | 111101111   | $-248$            |
| 011000100 | $768$              | $011110000$ | $+\infty$         |


*2.89 我们在一个 int 类型为 32 位补码表示的机器上运行程序。float 类型的值使用 32 位 IEEE 格式，而 double 类型的值使用 64 位 IEEE 格式。
我们产生随机整数 x、y 和 z，并且把它们转换成 double 类型的值：
```c
/* Create some arbitrary values */
int x = random();
int y = random();
int z = random();

/* Convert to double */
double dx = (double) x;
double dy = (double) y;
double dz = (double) z;
```
对于下列的每个C表达式，你要指出表达式是否总是为1。如果它总是为1，描述其中的数学原理。查则，列举出使它为0的参数的例子。请注意，不能使用IA32机器运行GCC来测试你的答案，因为对于float和double，它使用的都是80位的扩展精度表示。
A. `(float)x==(float)dx`
真，32位在 float 精度范围以内。

B. `dx-dy==(double) (x-y)`
假，整数溢出时

C. `(dx+dy)+dz==dx+(dy+dz)`
真，范围内能准确表示

D. `(dx*dy)*dz==dx*(dy*dz)`
假，大于 $2^{53}$ 会发生舍入误差

E. `dx/dx==dz/dz`
假，可能会得到 NaN


**2.90** 分配给你一个任务，编写一个C函数来计算 $2^{x}$ 的浮点表示。你意识到完成这个任务的最好方法是直接创建结果的IEEE单精度表示。当 $x$ 太小时，你的程序将返回 0.0 。当 $x$ 太大时，它会返回 $+\infty$ 。填写下列代码的空白部分，以计算出正确的结果。假设函数u2f返回的浮点值与它的无符号参数有相同的位表示。

```c
float fpwr2(int x)
{
    /* Result exponent and fraction */
    unsigned exp, frac;
    unsigned u;

    if (x < -149) {
        /* Too small.  Return 0.0 */
        exp = 0;
        frac = 0;
    } else if (x < -126) {
        /* Denormalized result */
        exp = 0;
        frac = 149 + x;
    } else if (x < 128) {
        /* Normalized result. */
        exp = 127 + x;
        frac = 0;
    } else {
        /* Too big. Return +oo */
        exp = 0xFF;
        frac = 0;
    }
    
    /* Pack exp and frac into 32 bits */
    u = exp << 23 | frac;
    /* Return as float */
    return u2f(u);
}
```

**2.91** 大约公元前250年，希腊数学家阿基米德证明了 $\frac{223}{71}<\pi<\frac{22}{7}$ 。如果当时有一台计算机和标准库 <math.h>，他就能够确定 $\pi$ 的单精度浮点近似值的十六进制表示为0x40490FDB。当然，所有的这些都只是近似值，因为 $\pi$ 不是有理数。

A. 这个浮点值表示的二进制小数是多少？
$11.0010010000111111011011_{2}$

B. $\frac{22}{7}$ 的二进制小数表示是什么？提示：参见家庭作业2.83。
$11.001001[001]_{2}$

C. 这两个 $\pi$ 的近似值从哪一位（相对于二进制小数点）开始不同的？
第九位。


**2.92** 遵循位级浮点编码规则，实现具有如下原型的函数：

```c
/* Compute -f. If f is NaN, then return f. */
float_bits float_negate(float_bits f);
```

对于浮点数 $f$ ，这个函数计算 $-f$。如果 $f$ 是 $NaN$，你的函数应该简单地返回 $f$ 。
测试你的函数，对参数 $f$ 可以取的所有 $2^{22}$ 个值求值，将结果与你使用机器的浮点运算得到的结果相比较。

```c
float_bits float_negate(float_bits f) {
    if ((f & 0x7FFFFFFF) > 0x7F800000) {
        return f;
    }
    return f ^ (1 << 31);
}
```


**2.93** 遵循位级浮点编码规则，实现具有如下原型的函数：

```c
/* Compute |f|. If f is NaN, then return f. */
float_bits float_absval(float_bits f);
```
对于浮点数 $f$ ，这个函数计算 $|f|$ 。如果 $f$ 是 $NaN$ ，你的函数应该简单地返回 $f$ 。
测试你的函数，对参数 $f$ 可以取的所有 $2^{32}$ 个值求值，将结果与你使用机器的浮点运算得到的结果相比较。

```c
float_bits float_absval(float_bits f) {
    if ((f & 0x7FFFFFFF) > 0x7F800000) {
        return f;
    }
    return f & 0x7FFFFFFF;
}
```


**2.94** 遵循位级浮点编码规则，实现具有如下原型的函数：
```c
/* Compute 2*f. If f is NaN, then return f. */
float_bits float_twice(float_bits f);
```

对于浮点数 $f$，这个函数计算 $2.0 \cdot f$。如果 $f$ 是 NaN，你的函数应该简单地返回 $f$。

测试你的函数，对参数 $f$ 可以取的所有 $2^{32}$ 个值求值，将结果与你使用机器的浮点运算得到的结果相比较。

```c
float_bits float_twice(float_bits f) {
    unsigned s = f & 0x80000000;
    f &= 0x7FFFFFFF;

    if (f >= 0x7F800000) {
        return s | f;
    }

    if (f < 0x00800000) {
        f <<= 1;
    } else {
        f += 0x00800000;
        if (f > 0x7F800000) {
            f = 0x7F800000;
        }
    }

    return s | f;
}
```

**2.95** 遵循位级浮点编码规则，实现具有如下原型的函数：
```c
/* Compute 0.5*f. If f is NaN, then return f. */
float_bits float_half(float_bits f);
```

对于浮点数 $f$，这个函数计算 $0.5 \cdot f$。如果 $f$ 是 NaN，你的函数应该简单地返回 $f$。

测试你的函数，对参数 $f$ 可以取的所有 $2^{32}$ 个值求值，将结果与你使用机器的浮点运算得到的结果相比较。

```c
float_bits float_half(float_bits f) {
    unsigned s = f & 0x80000000;
    f &= 0x7FFFFFFF;

    if (f >= 0x7F800000) {
        return s | f;
    }

    if (f >= 0x01000000) {
        f -= 0x00800000;
    } else {
        f += (f & 3) == 3;
        f >>= 1;
    }
    return s + f;
}
```


**2.96** 遵循位级浮点编码规则，实现具有如下原型的函数：
```c
/*
 * Compute (int) f.
 * If conversion causes overflow or f is NaN, return 0x80000000
 */
int float_f2i(float_bits f);
```
对于浮点数 $f$，这个函数计算 (int) $f$ 。如果 $f$ 是 $NaN$ ，你的函数应该向零舍人。如果 $f$ 不能用整数表示（例如，超出表示范围，或者它是一个 $NaN$），那么函数应该返回 0x80000000。
测试你的函数，对参数 $f$ 可以取的所有 $2^{32}$ 个值求值，将结果与你使用机器的浮点运算得到的结果相比较。

```c
int float_f2i(float_bits f) {
    unsigned s = f & 0x80000000;
    int frac = (f & 0x7FFFFF) | 0x800000;
    int exp = (f & 0x7F800000) >> 23;
    int E = exp - 127;

    if (E >= 31) {
        return 0x80000000;
    }
    if (E < 0) {
        return 0;
    }

    unsigned V;
    if (E <= 23) {
        V = frac >> (23 - E);
    } else {
        V = frac << (E - 23);
    }
    return s ? -V : V;
}
```

**2.97** 遵循位级浮点编码规则，实现具有如下原型的函数：

```c
/* Compute (float) i */
float_bits float_i2f(int i);
```

对于函数 i，这个函数计算 (float) i 的位级表示。
测试你的函数，对参数 $f$ 可以取的所有 $2^{32}$ 个值求值，将结果与你使用机器的浮点运算得到的结果相比较。

```c
float_bits float_i2f(int i) {
    if (i == 0) {
        return 0;
    }

    unsigned s = i & 0x80000000;
    unsigned exp;
    unsigned frac;

    if (s) {
        i = -i;
    }

    int k = (sizeof(int) << 3) - __builtin_clz(i) - 1;
    exp = k + 127;
    if (k <= 23) {
        frac = (i ^ (1 << k)) << (23 - k);
    } else {
        unsigned shift = k - 23;
        frac = (i ^ (1 << k)) >> shift;

        unsigned mid = 1 << (shift - 1);
        unsigned r = i & ((1 << shift) - 1);
        if (r > mid || (r == mid && (frac & 1))) {
            frac++;
            if (frac == 0x800000) {
                frac = 0;
                exp++;
            }
        }
    }

    exp <<= 23;
    return s | exp | frac;
}
```