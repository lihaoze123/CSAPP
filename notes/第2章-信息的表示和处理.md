---
type: chapter
tags:
  - CSAPP
status: 学习中
---
# 信息存储

## 字数据大小

**字长**（word size）表示虚拟地址空间的最大大小（位数）。也会影响 C 数据类型的大小。

> [!note]- 基本 C 数据类型的典型大小
> | C 声明          | 数据类型           | 32 位 | 64 位 | 说明                           |
> | :----------- | :------------- | :--- | :--- | :--------------------------- |
> | `char`       | 字符             | 1    | 1    |                               |
> | `short`      | 短整数            | 2    | 2    |                               |
> | `int`        | 整数             | 4    | 4    |                               |
> | `long`       | 长整数            | 4    | 8    | **32位和64位的关键区别**          |
> | `long long`  | 长长整数           | 8    | 8    | ISO C99 引入                  |
> | `char*`      | 指针             | 4    | 8    | 指针大小等于字长                    |
> | `float`      | 单精度浮点数          | 4    | 4    | IEEE 754 标准                  |
> | `double`     | 双精度浮点数          | 8    | 8    | IEEE 754 标准                  |
>

## 字节顺序

多字节对象都被存储为连续的字节序列，对想的地址为所使用的字节中最小的地址，例如：`int x` （32 位整形）的地址为 `0x100`，`x` 的四个字节存储在 `0x100`、`0x101`、`0x102`、`0x103`。

字节顺序分为两种：**大端法** 和 **小端法**。

以 `int x = 0x12345678` 为例，起始地址为 `0x100`：
### 大端法 (Big Endian)

最高有效字节在最低地址（人类阅读顺序，网络字节序标准）

|   内存地址   | 0x100  | 0x101  | 0x102  | 0x103  |
| :------: | :----: | :----: | :----: | :----: |
| **存储内容** | `0x12` | `0x34` | `0x56` | `0x78` |
| **字节说明** |  最高位   |        |        |  最低位   |
### 小端法 (Little Endian)

最低有效字节在最低地址（Intel x86/x86-64 架构采用）

|   内存地址   | 0x100  | 0x101  | 0x102  | 0x103  |
| :------: | :----: | :----: | :----: | :----: |
| **存储内容** | `0x78` | `0x56` | `0x34` | `0x12` |
| **字节说明** |  最低位   |        |        |  最高位   |

需要考虑字节顺序的三种情况：
1. 不同类型机器之间通过网络传送二进制数据
2. 阅读表示整形数据的字节序列
3. 编写规避正常的类型系统的程序时（**强制类型转换** 或 **联合**）

编码字符串时和字节顺序无关。

## 移位

**左移** 时低位补充零。

**右移** 分为 **逻辑右移** 和 **算数右移**。逻辑右移是在左端补零，算数右移是在左端补最高有效位的值

> [!example]- 移位操作示例
>
> **假设**：`x` 为 16 位有符号整数，`x = 0b11010010_10110100` （十进制 -10904，最高位为 1，表示负数）
>
> **左移 2 位** (`x << 2`)：
> ```
> 原始:  11010010 10110100
>         ↓ 向左移动 2 位
> 结果:  01001010 11010000
>         ↑ 低位补 0
> ```
>
> **逻辑右移 2 位** (无符号数右移)：
> ```
> 原始:  11010010 10110100
>         ↓ 向右移动 2 位
> 结果:  00110100 10101101
>         ↑ 高位补 0
> ```
>
> **算术右移 2 位** (有符号数右移)：
> ```
> 原始:  11010010 10110100
>         ↓ 向右移动 2 位
> 结果:  11110100 10101101
>         ↑ 高位补符号位（1）
> ```
>
> **关键区别**：
> - 逻辑右移：高位补 0，用于**无符号数**
> - 算术右移：高位补**符号位**，保持符号不变，用于**有符号数**

几乎所有编译器都对 **有符号数** 使用 **算数右移**，对 **无符号数** 必须是 **逻辑右移**。

# 整数表示

## 整形编码

**无符号数**（unsigned）：$\operatorname{B 2 U}(X) = \sum_{i = 0}^{w - 1} x_{i} \cdot 2^i$
**有符号数**（two's complement 补码）：$\operatorname{B2T}(X) = -x_{w - 1} \cdot 2^{w - 1} + \sum_{i = 0}^{w - 2} x_{i} \cdot 2^{i}$
**符号位**：$0$ 表示非负数，$1$ 表示负数。

>[!note]- 有符号数的另外两种表示方法
>
> 除了补码(two's complement)外,历史上还使用过**原码**和**反码**:
>
> ### 原码 (Sign-Magnitude)
>
> **表示方法**: 符号位 + 绝对值的二进制表示
>
> **公式**: $\operatorname{B2S}(X) = (-1)^{x_{w-1}} \cdot \sum_{i=0}^{w-2} x_i \cdot 2^i$
>
> **特点**:
> - 最高位为符号位(0=正,1=负)
> - 其余位表示绝对值
> - 有两个零: $+0$ (`00...0`) 和 $-0$ (`10...0`)
>
> **示例** (4位):
> 
> | 位模式 | 原码值 |
> | :---: | :---: |
> | `0010` | +2 |
> | `1010` | -2 |
> | `0000` | +0 |
> | `1000` | -0 |
>
> **缺点**:
> - 计算复杂(需要判断符号位)
> - 有两个零表示
> - 数值范围不对称: $-(2^{w-1}-1)$ 到 $+(2^{w-1}-1)$
>
> ### 反码 (Ones' Complement)
>
> **表示方法**: 正数同原码,负数为原码按位取反(符号位除外)
>
> **公式**: $\operatorname{B2O}(X) = -x_{w-1} \cdot (2^{w-1} - 1) + \sum_{i=0}^{w-2} x_i \cdot 2^i$
>
> **特点**:
> - 正数: 同原码
> - 负数: 原码除符号位外按位取反
> - 也有两个零: $+0$ (`00...0`) 和 $-0$ (`11...1`)
>
> **示例** (4位):
> 
> | 位模式 | 反码值 | 说明 |
> | :---: | :---: | :--- |
> | `0010` | +2 | 正数 |
> | `1101` | -2 | 负数: +2 (`0010`) 按位取反 |
> | `0000` | +0 | 正零 |
> | `1111` | -0 | 负零 |
>
> **缺点**:
> - 仍有两个零
> - 加法运算需要处理循环进位
>


> [!example]- C short（2 字节）的表示
>
> 同样的位模式，作为无符号数和有符号数解释时值不同：
>
> | 无符号数 $\to$ (unsigned) | 十六进制 | 二进制 | 有符号数 $\to$ (signed) |
> | :--- | :--- | :--- | :--- |
> | 0 | 0x0000 | 0000 0000 0000 0000 | 0 |
> | 1 | 0x0001 | 0000 0000 0000 0001 | 1 |
> | 32767 | 0x7FFF | 0111 1111 1111 1111 | 32767 |
> | 32768 | 0x8000 | 1000 0000 0000 0000 | -32768 |
> | 65535 | 0xFFFF | 1111 1111 1111 1111 | -1 |


>[!example]- $w = 16$ 时的位模式和数值
>
>| 名称       | 十进制    | 十六进制   | 二进制                 |
>| :------- | :----- | :----- | :------------------ |
>| **UMax** | 65535  | 0xFFFF | 1111 1111 1111 1111 |
>| **TMax** | 32767  | 0x7FFF | 0111 1111 1111 1111 |
>| **TMin** | -32768 | 0x8000 | 1000 0000 0000 0000 |
>| **-1**   | -1     | 0xFFFF | 1111 1111 1111 1111 |
>| **0**    | 0      | 0x0000 | 0000 0000 0000 0000 |
>
>- $|TMin| = TMax + 1$
>- $UMax = 2 \times TMax + 1$

### 有符号数和无符号数之间的转换

$W = 4$ 时，位模式 $X$ 作为无符号数 $\operatorname{B2U}(X)$ 和有符号数 $\operatorname{B2T}(X)$ 的不同值：

| $X$ (位模式) | $\operatorname{B2U}(X)$ (无符号) | $\operatorname{B2T}(X)$ (有符号) |
| :-------: | :---------------------------: | :---------------------------: |
|   0000    |               0               |               0               |
|   0001    |               1               |               1               |
|   0010    |               2               |               2               |
|   0011    |               3               |               3               |
|   0100    |               4               |               4               |
|   0101    |               5               |               5               |
|   0110    |               6               |               6               |
|   0111    |               7               |               7               |
|   1000    |               8               |            **-8**             |
|   1001    |               9               |            **-7**             |
|   1010    |              10               |            **-6**             |
|   1011    |              11               |            **-5**             |
|   1100    |              12               |            **-4**             |
|   1101    |              13               |            **-3**             |
|   1110    |              14               |            **-2**             |
|   1111    |              15               |            **-1**             |

观察上表，可以看到函数 $T2U$ 的一个属性：

对满足 $TMin_{w} \leq x \leq TMax_{w}$ 的 $x$ 有：

$$
T2U_{w}(x) = 
\begin{cases}
x + 2^{w}, &x < 0 \\
x, &x \geq 0
\end{cases}
$$

反过来，有：
$$
U2T_{w}(u) =
\begin{cases}
u, &u \leq TMax_{w} \\
u - 2^{w}, &u > TMax_{w}
\end{cases}
$$

## 整形增长

无符号整数直接补零，有符号进行 **符号扩展**。
### 符号扩展（Sign Extension）

不改变其值的情况下，给定一个 $w$ 位的有符号整数 $x$，转化为一个 $w + k$ 位的有符号整数：

$$X' = [\underbrace{x_{w-1}, \dots, x_{w-1}}_{k \text{ copies of MSB}}, x_{w-1}, x_{w-2}, \dots, x_{0}]$$

**方法**：将符号位（最高有效位 MSB）向左复制 $k$ 次

> [!example]- 示例：4 位 $\to$ 8 位
> **正数扩展**（符号位 = 0）：
>  
> ```
> 原始 4 位:   0010    (十进制: 2)
>             ↑
>          符号位(0)
> 
> 扩展 8 位:   00000010    (十进制: 2)
>             ↑↑↑↑
>          复制 4 次符号位
> ```
> 
> **负数扩展**（符号位 = 1）：
> ```
> 原始 4 位:   1010    (十进制: -6)
>             ↑
>          符号位(1)
> 
> 扩展 8 位:   11111010    (十进制: -6)
>             ↑↑↑↑
>          复制 4 次符号位
> ```

> [!note]- 为什么有效？
> 补码的数学定义：
>  $$\operatorname{B2T}(X) = -x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i$$
> 当我们复制符号位时，新增的高位值为：
$$-x_{w-1} \cdot (2^{w+k-1} + 2^{w+k-2} + \dots + 2^{w}) = -x_{w-1} \cdot 2^{w-1} \cdot (2^k - 1)$$
> 加上原来的符号位贡献：$-x_{w-1} \cdot 2^{w-1}$
> 总计：$-x_{w-1} \cdot 2^{w-1} \cdot 2^k = -x_{w-1} \cdot 2^{w+k-1}$

^005eed

## 整形截断

相当于模运算：
- **无符号**：`10011 -> 0011` $19 \to 3$
- **有符号**：`10011 -> 0011` $-13 \to 3$
对于补码来说，$x' = U2T_{k}(x \bmod 2^{k})$
# 整数运算

## 加法

### 无符号加法
![[Pasted image 20260124165921.png]]
无符号加法忽略进位。
**公式**：$s = \operatorname{UAdd}_{w}(u, v) = u + v \bmod{2^{w}}$

### 有符号加法
![[Pasted image 20260124171013.png]]
有符号加法在编码上的行为和无符号一样。

**公式**：$s = \operatorname{TAdd}_{w}(u, v) = \operatorname{UAdd}_{w}(u, v)$

### 溢出判断

**无符号加法溢出**（当 $u + v \ge 2^w$ 时）：
- **判断条件**：$s < u$ 或 $s < v$（和小于任一加数）
- **C 检测**：`if (s < u) /* 溢出 */`

**有符号加法溢出**（正溢出或负溢出）：
- **正溢出**（正 + 正 = 负）：$u > 0, v > 0, s < 0$
- **负溢出**（负 + 负 = 正）：$u < 0, v < 0, s \ge 0$
- **C 检测**：`if ((u > 0 && v > 0 && s < 0) || (u < 0 && v < 0 && s >= 0)) /* 溢出 */`

## 乘法

### 无符号乘法
![[Pasted image 20260124171837.png]]
同样是模运算：$\operatorname{UMult}_{w}(u, v) = u \cdot v \bmod 2^{w}$

### 有符号乘法
![[Pasted image 20260124172156.png]]
编码上跟无符号一样。
也即：$\operatorname{TMult}_{w}(u, v) = U2T_{w}(u \cdot v \bmod 2^{w})$

### 移位

正常情况下，移位的表现是熟知的。

对于补码来说，负数算数右移的表现是向负无穷取整：`-3 (1101) >> 1 = -2 (1110)`，需要加偏移量：`-3 (1101) + 1 (= 1110) >> 1 = -1 (1111)`。

> [!warning]- 整数乘法优化
> 编译器通常用 **移位 + 加法** 优化乘以常数的乘法：
> - `x * 14` → `x * 16 - x * 2` → `(x << 4) - (x << 1)`
> - `x * 15` → `x * 16 - x` → `(x << 4) - x`
>
> 这比直接用乘法指令更高效。

## 求反

对于无符号数，求反就是求模运算意义下的逆元。

对于有符号数，两种方法：
- 按位取反加一
- 找到二进制表示中最低位的 `1` 然后将比这一位高的位取反。

# 浮点数

## 二进制小数

一个形如 $b_{m}b_{m - 1} \cdots b_{2}b_{1}b_{0}.b_{-1}b_{-1} \cdots b_{-n + 1}b_{-n}$ 的二进制小数，其左边的位权形如 $2^{i}$，右边的位权形如 $1/2^{i}$

这样表示的数 $b$ 的定义 $b = \displaystyle\sum_{i=-n}^{m}2^{i}\times b_{i}$

对于这种表现形式，左移右移相当于乘/除。

$0.1111\dots_{2}$ 表示刚好小于 $1$ 的数，用 $1.0 - \varepsilon$ 表示。

>[!note]- 局限性
>1. 只能表示形如 $\frac{x}{2^{k}}$ 的小数，其他形式只能近似表示。
>2. 在有限长度编码之内只能表示有限的数。  


## IEEE 浮点表示

浮点数表示形式形如 $(-1)^{s} \cdot M \cdot 2^{E}$，其中：
- $s$ 是符号位，表示是负数（$s = 1$）还是正数（$s = 0$）。
- $M$ 是尾数，表示范围 $[1.0, 2.0)$ 的二进制小数。
- $E$ 是阶码，对浮点数加权。

浮点数的位表示使用三个字段编码：
- 符号位 $s$ 编码符号。
- $exp$ 字段编码 $E$。
- $frac$ 字段编码 $M$。

>[!note]- 单精度浮点数和双精度浮点数
>IEEE 提供了单精度 32 位和双精度 64 位浮点格式：
>
>| 格式   | 总位数 | 符号位 $s$ | 阶码 $exp$ | 尾数 $frac$ | 偏置值 $Bias$ |
>| :----- | :-----: | :--------: | :--------: | :---------: | :----: |
>| 单精度 |   32    |     1      |     8      |      23     |  127   |
>| 双精度 |   64    |     1      |     11     |      52     |  1023  |

### 规格化的值

当 $exp$ 字段**不全为 0 且不全为 1** 时（即 $0 < exp < 2^k - 1$），浮点数称为**规格化的值**。

**计算规则**：
- **阶码**：$E = exp - Bias$
- **尾数**：$M = 1.frac$（$frac$ 字段前隐含前导 1）

> [!example]- 示例
> 对于 $F = 15213.0$（单精度浮点数）：
>$$
> \begin{aligned}
> 15213_{10} &= 11101101101101_{2} \\
> &= 1.1101101101101_{2} \times 2^{13}
> \end{aligned}
> $$
>
> **各字段计算**：
> - **符号位** $s = 0$（正数）
> - **阶码** $E = 13$，$exp = 13 + 127 = 140 = 10001100_{2}$
> - **尾数** $frac = 11011011011010000000000$（取小数部分前 23 位）
>
> **最终位表示**：
> ```
> 0 10001100 11011011011010000000000
> s  exp          frac
> ```
>
> **十六进制**：`0x466DB400`

### 非规格化的值

当 $exp$ 字段**全为 0** 时（即 $exp = 0$），浮点数称为**非规格化的值**。

**计算规则**：
- **阶码**：$E = 1 - Bias$（不再减 exp，固定值）
- **尾数**：$M = 0.frac$（**不包含**隐含的前导 1）

**用途**：
1. 表示数值 0（当 $frac$ 也全为 0 时）
2. 表示非常接近 0.0 的小数（非规格化数）

> [!example]- 非规格化数示例（单精度）
> 假设位表示为 `0x00000001`：
> ```
> s = 0, exp = 00000000, frac = 000...001
> ```
> - $E = 1 - 127 = -126$
> - $M = 2^{-23}$
> - 值 $= (-1)^0 \times 2^{-126} \times 2^{-23} = 2^{-149} \approx 1.4 \times 10^{-45}$

>[!note]- 为什么偏置量是 1 而不是 0？
>最大非规格化值和最小规格化值的平滑转变：
>![[Pasted image 20260125132404.png]]

### 特殊值

当 $exp$ 字段**全为 1** 时（即 $exp = 2^k - 1$），表示特殊值。

**类型**：

| $exp$ | $frac$ | 值                      | 说明                                       |
| :---- | :----- | :--------------------- | :--------------------------------------- |
| 全 1   | 全 0    | $(-1)^s \times \infty$ | 无穷大（$s=0$ 为 $+\infty$，$s=1$ 为 $-\infty$） |
| 全 1   | 非 0    | **NaN**                | Not a Number（非数值）                        |

**产生 NaN 的情况**：
- $\infty - \infty$
- $\infty / \infty$
- $\sqrt{-1}$
- $0 / 0$

### 舍入

由于浮点数只能表示有限精度的数值，需要对计算结果进行舍入。

**IEEE 舍入方法**：
1. **向偶数舍入**（Round-to-Even，默认）：舍入到最接近的值，当有两个值同样接近时选择最低有效位为 0 的那个
2. **向零舍入**（Round-Toward-Zero）：截断
3. **向下舍入**（Round-Toward-Negative）：$-\infty$
4. **向上舍入**（Round-Toward-Positive）：$+\infty$

> [!example]- 向偶数舍入示例
> - $2.5 \to 2$（二进制 $10.1$，舍入到 $10$，LSB 为 0）
> - $3.5 \to 4$（二进制 $11.1$，舍入到 $100$，LSB 为 0）
> - $2.4 \to 2$
> - $2.6 \to 3$

>[!note]- Why 向偶数舍入？
>向上舍入和向下舍入都会导致统计偏差，但是向偶数舍入在统计意义上向上和向下的情况各占一半。

> [!example]- 舍入二进制小数
>
> 将二进制小数舍入到小数点后 $k$ 位
>
> **规则**：
> 1. 第 $k$ 位为 $0$ 时相当于“偶”
> 2. 被舍入位右侧形如 $100\dots_{2}$ 时相当于“中间”
> 
> ![[Pasted image 20260125140018.png]]


### 浮点运算

浮点数运算不满足结合律和分配律：

> [!example]- 运算性质示例
> **不满足结合律**：
> ```c
> (3.14 + 1e10) - 1e10  // 结果为 0.0（精度丢失）
> 3.14 + (1e10 - 1e10)  // 结果为 3.14
> ```
>
> **不满足分配律**：
> ```c
> 2.0 * (3.0 + 4.0)  // 结果为 14.0
> 2.0 * 3.0 + 2.0 * 4.0  // 结果可能有细微差异
> ```

### C 语言中的浮点数

**类型与对应格式**：
- `float`：单精度（32 位）
- `double`：双精度（64 位）
- `long double`：扩展精度（80-128 位，取决于实现）

**转换规则**：
- int → float：数值可能舍入，但不会溢出
- float/int → double：精确（double 精度更高）
- double → float：可能溢出为 $\pm \infty$ 或舍入
- float/double → int：向零舍入，可能溢出（**未定义行为**）

